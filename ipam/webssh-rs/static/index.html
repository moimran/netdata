<!DOCTYPE html>
<html>
<head>
    <title>IPAM Terminal</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@4.19.0/css/xterm.css" />
    <style>
        body {
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            font-family: Arial, sans-serif;
        }
        
        .header {
            background-color: #333;
            color: white;
            padding: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .connection-info {
            display: flex;
            gap: 15px;
        }
        
        .terminal-area {
            flex: 1;
            background-color: black;
            padding: 10px;
        }
        
        #terminal {
            height: 100%;
            width: 100%;
        }
    </style>
</head>
<body>
    <div class="header">
        <h2>IPAM Terminal</h2>
        <div class="connection-info">
            <span>Device: <span id="device-hostname">Not connected</span></span>
            <span>User: <span id="connection-username">Not connected</span></span>
            <span>Session: <span id="session-id">Not connected</span></span>
            <button onclick="disconnectSession()">Disconnect</button>
            <button onclick="reconnectSession()">Reconnect</button>
            <button onclick="sendEnterKey()">Send Enter</button>
        </div>
    </div>
    
    <div class="terminal-area">
        <div id="terminal"></div>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/xterm@4.19.0/lib/xterm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.5.0/lib/xterm-addon-fit.js"></script>
    
    <script>
        // Global variables
        let term = null;
        let ws = null;
        let fitAddon = null;
        let currentSessionId = null;
        let isApiConnection = false;
        
        // Show error message
        function showError(message) {
            term.writeln('\x1b[1;31mError: ' + message + '\x1b[0m');
            console.error('Error:', message);
        }
        
        // Initialize terminal
        function initTerminal() {
            // Initialize terminal
            term = new Terminal({
                cursorBlink: true,
                fontSize: 14,
                fontFamily: 'monospace',
                theme: {
                    background: '#000',
                    foreground: '#fff'
                }
            });
            
            // Create fit addon
            fitAddon = new FitAddon.FitAddon();
            term.loadAddon(fitAddon);
            
            // Open terminal
            term.open(document.getElementById('terminal'));
            
            // Set terminal options for better compatibility
            term.options.scrollback = 1000;
            term.options.cursorBlink = true;
            
            // Focus the terminal
            term.focus();
            
            // Fit terminal to container
            setTimeout(() => {
                fitAddon.fit();
                term.writeln('\x1b[1;32mWelcome to IPAM Terminal\x1b[0m');
                term.writeln('Terminal initialized and ready for use');
                
                // Check URL parameters for API-initiated connection
                const urlParams = new URLSearchParams(window.location.search);
                let sessionId = urlParams.get('session_id');
                const hostname = urlParams.get('hostname');
                const username = urlParams.get('username');
                const deviceName = urlParams.get('device_name');
                
                if (sessionId) {
                    // Extract just the session ID without any additional parameters
                    if (sessionId.includes('&')) {
                        sessionId = sessionId.split('&')[0];
                    }
                    
                    term.writeln('\x1b[1;34mConnecting to session: ' + sessionId + '\x1b[0m');
                    isApiConnection = true;
                    
                    // Update UI with available information
                    if (hostname) document.getElementById('device-hostname').textContent = hostname;
                    if (username) document.getElementById('connection-username').textContent = username;
                    document.getElementById('session-id').textContent = sessionId;
                    
                    // Connect directly to WebSocket without checking status
                    connectWebSocket(sessionId);
                }
            }, 100);
        }
        
        // Connect to WebSocket
        function connectWebSocket(sessionId) {
            if (ws) {
                ws.close();
            }
            
            currentSessionId = sessionId;
            
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws/${sessionId}`;
            
            term.writeln(`\x1b[1;34mConnecting to WebSocket: ${wsUrl}\x1b[0m`);
            
            ws = new WebSocket(wsUrl);
            
            ws.onopen = () => {
                term.writeln('\x1b[1;32mWebSocket connection established\x1b[0m');
                
                // Send terminal size
                const dimensions = { 
                    type: 'resize',
                    rows: term.rows,
                    cols: term.cols
                };
                ws.send(JSON.stringify(dimensions));
                
                // Handle terminal input with debouncing
                let inputQueue = [];
                let processingInput = false;
                
                term.onData(data => {
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        // Add the data to the queue
                        inputQueue.push(data);
                        console.log('Input queued:', data);
                        
                        // Process the queue if not already processing
                        if (!processingInput) {
                            processingInput = true;
                            processInputQueue();
                        }
                    }
                });
                
                // Process the input queue with a small delay to prevent multiple messages
                function processInputQueue() {
                    if (inputQueue.length > 0) {
                        const data = inputQueue.shift();
                        
                        // Send the data to the server
                        console.log('Sending input to server:', data);
                        ws.send(JSON.stringify({
                            type: 'input',
                            data: data
                        }));
                        
                        // Process the next item in the queue after a small delay
                        setTimeout(processInputQueue, 10);
                    } else {
                        processingInput = false;
                    }
                }
                
                // Focus terminal and send an initial Enter key to trigger prompt
                setTimeout(() => {
                    term.focus();
                    // Send an Enter key to trigger the prompt
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        console.log('Sending initial Enter key');
                        ws.send(JSON.stringify({ type: 'input', data: '\r' }));
                    }
                }, 500);
            };
            
            ws.onmessage = (event) => {
                console.log('WebSocket message received:', event.data);
                
                const data = event.data;
                if (data instanceof Blob) {
                    // Handle binary data
                    const reader = new FileReader();
                    reader.onload = () => {
                        console.log('Binary data received');
                        term.write(new Uint8Array(reader.result));
                    };
                    reader.readAsArrayBuffer(data);
                } else {
                    try {
                        // Check if it's a JSON message
                        const jsonData = JSON.parse(data);
                        console.log('JSON data received:', jsonData);
                        
                        if (jsonData.type === 'output') {
                            console.log('Terminal output received:', jsonData.data);
                            term.write(jsonData.data);
                        } else if (jsonData.type === 'error') {
                            showError(jsonData.data);
                        } else if (jsonData.type === 'status' && jsonData.status === 'disconnected') {
                            // Handle disconnection status
                            term.write('\r\n\nDisconnected from device\r\n');
                        } else {
                            console.log('Unknown message type:', jsonData.type);
                        }
                    } catch (e) {
                        // Not JSON, just write the data directly
                        console.log('Raw text data received:', data);
                        term.write(data);
                    }
                }
            };
            
            ws.onclose = () => {
                term.writeln('\x1b[1;31mWebSocket connection closed\x1b[0m');
                
                // Update UI elements
                document.getElementById('device-hostname').textContent = 'Not connected';
                document.getElementById('connection-username').textContent = 'Not connected';
                document.getElementById('session-id').textContent = 'Not connected';
                
                // Clear terminal
                term.clear();
                term.writeln('Connection closed');
                
                ws = null;
                currentSessionId = null;
            };
            
            ws.onerror = (error) => {
                showError('WebSocket error: ' + error.message);
            };
        }
        
        // Check session status and connect
        function checkSessionAndConnect(sessionId) {
            term.writeln(`\x1b[1;34mChecking session status for: ${sessionId}\x1b[0m`);
            
            fetch(`/api/session/${sessionId}/status`)
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'active') {
                        // Update UI elements
                        document.getElementById('device-hostname').textContent = data.hostname;
                        document.getElementById('connection-username').textContent = data.username;
                        document.getElementById('session-id').textContent = sessionId;
                        
                        // Connect WebSocket
                        connectWebSocket(sessionId);
                    } else if (data.status === 'closed') {
                        showError('Session is closed');
                    } else if (data.status === 'not_found') {
                        showError('Session not found');
                    } else {
                        showError('Unknown session status: ' + data.status);
                    }
                })
                .catch(error => {
                    showError('Failed to check session status: ' + error.message);
                });
        }
        
        // Disconnect function
        function disconnectSession() {
            if (currentSessionId) {
                term.writeln('\x1b[1;33mDisconnecting from session...\x1b[0m');
                
                fetch(`/api/session/${currentSessionId}/terminate`, {
                    method: 'POST'
                })
                .then(response => {
                    if (response.ok) {
                        term.writeln('\x1b[1;32mSession terminated successfully\x1b[0m');
                    } else {
                        showError('Failed to terminate session');
                    }
                })
                .catch(error => {
                    showError('Error terminating session: ' + error.message);
                });
                
                if (ws) {
                    ws.close();
                }
            } else {
                term.writeln('\x1b[1;33mNo active session to disconnect\x1b[0m');
            }
        }
        
        // Reconnect function
        function reconnectSession() {
            if (currentSessionId) {
                term.writeln('\x1b[1;33mReconnecting to session: ' + currentSessionId + '\x1b[0m');
                connectWebSocket(currentSessionId);
            } else {
                // Check URL parameters for session ID
                const urlParams = new URLSearchParams(window.location.search);
                let sessionId = urlParams.get('session_id');
                
                if (sessionId) {
                    // Extract just the session ID without any additional parameters
                    if (sessionId.includes('&')) {
                        sessionId = sessionId.split('&')[0];
                    }
                    
                    term.writeln('\x1b[1;33mReconnecting to session: ' + sessionId + '\x1b[0m');
                    connectWebSocket(sessionId);
                } else {
                    term.writeln('\x1b[1;33mNo session ID available for reconnection\x1b[0m');
                }
            }
        }
        
        // Send Enter key function
        function sendEnterKey() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                term.writeln('\x1b[1;33mSending Enter key...\x1b[0m');
                ws.send(JSON.stringify({ type: 'input', data: '\r' }));
            } else {
                term.writeln('\x1b[1;33mWebSocket not connected\x1b[0m');
            }
        }
        
        // Handle window resize
        window.onresize = function() {
            if (fitAddon) {
                fitAddon.fit();
                
                if (ws && ws.readyState === WebSocket.OPEN) {
                    const dimensions = {
                        type: 'resize',
                        rows: term.rows,
                        cols: term.cols
                    };
                    ws.send(JSON.stringify(dimensions));
                }
            }
        };
        
        // Initialize on page load
        window.onload = function() {
            initTerminal();
        };
    </script>
</body>
</html>
