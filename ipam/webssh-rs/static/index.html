<!DOCTYPE html>
<html>
<head>
    <title>IPAM Terminal</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@4.19.0/css/xterm.css" />
    <style>
        body {
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            font-family: Arial, sans-serif;
        }
        
        .header {
            background-color: #333;
            color: white;
            padding: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .connection-info {
            display: flex;
            gap: 15px;
        }
        
        .terminal-area {
            flex: 1;
            background-color: black;
            padding: 5px;
            position: relative;
            overflow: hidden;
        }
        
        #terminal {
            height: 100%;
            width: 100%;
            overflow: hidden;
        }
        
        /* Ensure terminal has proper dimensions for commands like top */
        .xterm-viewport {
            overflow-y: hidden !important;
        }
        
        /* Ensure cursor is visible */
        .xterm-cursor-layer {
            z-index: 10;
        }
        
        /* Improve rendering for full-screen applications */
        .xterm-screen {
            image-rendering: pixelated;
        }
    </style>
</head>
<body>
    <div class="header">
        <h2>IPAM Terminal</h2>
        <div class="connection-info">
            <span>Device: <span id="device-hostname">Not connected</span></span>
            <span>User: <span id="connection-username">Not connected</span></span>
            <span>Session: <span id="session-id">Not connected</span></span>
            <button onclick="disconnectSession()">Disconnect</button>
            <button onclick="reconnectSession()">Reconnect</button>
            <button onclick="sendEnterKey()">Send Enter</button>
        </div>
    </div>
    
    <div class="terminal-area">
        <div id="terminal"></div>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/xterm@4.19.0/lib/xterm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.5.0/lib/xterm-addon-fit.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-web-links@0.6.0/lib/xterm-addon-web-links.js"></script>
    
    <script>
        // Global variables
        let term = null;
        let ws = null;
        let fitAddon = null;
        let currentSessionId = null;
        let isApiConnection = false;
        
        // Show error message
        function showError(message) {
            term.writeln('\x1b[1;31mError: ' + message + '\x1b[0m');
            console.error('Error:', message);
        }
        
        // Initialize terminal
        function initTerminal() {
            // Initialize terminal with improved settings for command output
            term = new Terminal({
                cursorBlink: true,
                scrollback: 1000,
                tabStopWidth: 8,
                bellStyle: 'sound',
                fontFamily: 'monospace',
                fontSize: 14,
                theme: {
                    background: '#000000',
                    foreground: '#ffffff'
                },
                allowTransparency: false,
                disableStdin: false,
                cursorStyle: 'block',
                convertEol: true,
                rendererType: 'canvas',
                allowProposedApi: true
            });
            
            // Create and load addons
            fitAddon = new FitAddon.FitAddon();
            term.loadAddon(fitAddon);
            
            // Fix for canvas readback warning
            // Set willReadFrequently attribute on the canvas to improve performance
            setTimeout(() => {
                const canvasElements = document.querySelectorAll('canvas');
                canvasElements.forEach(canvas => {
                    const ctx = canvas.getContext('2d', { willReadFrequently: true });
                });
            }, 100);
            
            // Add web links addon
            const webLinksAddon = new WebLinksAddon.WebLinksAddon();
            term.loadAddon(webLinksAddon);
            
            // Open terminal
            term.open(document.getElementById('terminal'));
            
            // Set terminal options for better compatibility
            term.options.cursorBlink = true;
            term.options.disableStdin = false;
            term.options.cursorStyle = 'block';
            term.options.scrollOnUserInput = true;
            
            // Set environment variables that help with terminal compatibility
            const envData = btoa(JSON.stringify({
                data: {
                    TERM: 'xterm-256color',
                    COLORTERM: 'truecolor',
                    TERM_PROGRAM: 'webssh-rs'
                }
            }));
            
            // Focus the terminal
            term.focus();
            
            // Apply fit to ensure terminal size is correct initially
            setTimeout(() => {
                fitAddon.fit();
                console.log(`Initial terminal size: ${term.cols}x${term.rows}`);
                
                // Add a mutation observer to detect changes to the terminal container
                // This helps with dynamic layouts and ensures the terminal always fits correctly
                const terminalElement = document.getElementById('terminal');
                const resizeObserver = new ResizeObserver(entries => {
                    for (let entry of entries) {
                        if (fitAddon) {
                            fitAddon.fit();
                            if (ws && ws.readyState === WebSocket.OPEN) {
                                console.log(`Container resize: sending new size ${term.cols}x${term.rows}`);
                                ws.send(JSON.stringify({
                                    type: 'resize',
                                    cols: term.cols,
                                    rows: term.rows
                                }));
                            }
                        }
                    }
                });
                
                // Start observing the terminal container
                resizeObserver.observe(terminalElement);
            }, 100);
            
            // Handle window resize events with debounce for better performance
            let resizeTimeout;
            window.addEventListener('resize', () => {
                // Clear previous timeout to implement debounce
                clearTimeout(resizeTimeout);
                
                // Set a new timeout to resize after a short delay
                resizeTimeout = setTimeout(() => {
                    if (fitAddon) {
                        fitAddon.fit();
                        
                        // Send updated terminal size to server
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            console.log(`Window resize: sending new size ${term.cols}x${term.rows}`);
                            ws.send(JSON.stringify({
                                type: 'resize',
                                cols: term.cols,
                                rows: term.rows
                            }));
                            
                            // Force a refresh after resize to ensure display is updated
                            term.clearSelection();
                            term.refresh(0, term.rows - 1);
                        }
                    }
                }, 100); // 100ms debounce
            });
            
            // Fit terminal to container and set size
            setTimeout(() => {
                fitAddon.fit();
                // Send terminal size to server
                if (ws && ws.readyState === WebSocket.OPEN) {
                    console.log(`Sending resize: ${term.cols}x${term.rows}`);
                    ws.send(JSON.stringify({
                        type: 'resize',
                        cols: term.cols,
                        rows: term.rows
                    }));
                }
                term.writeln('\x1b[1;32mWelcome to IPAM Terminal\x1b[0m');
                term.writeln('Terminal initialized and ready for use');
                
                // Set up a periodic refresh for the terminal
                // This helps with commands like 'top' that need regular updates
                const refreshInterval = setInterval(() => {
                    if (term && document.hasFocus()) {
                        // Only refresh if the page has focus to save resources
                        term.refresh(0, term.rows - 1);
                    }
                }, 2000); // Refresh every 2 seconds
                
                // Clean up the interval when the page is unloaded
                window.addEventListener('beforeunload', () => {
                    clearInterval(refreshInterval);
                });
                
                // Add event listener for terminal focus using the DOM element
                // since term.onFocus is not available in this version
                const terminalElement = document.getElementById('terminal');
                terminalElement.addEventListener('focus', () => {
                    // When terminal gets focus, ensure it's properly sized
                    if (fitAddon) {
                        fitAddon.fit();
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            ws.send(JSON.stringify({
                                type: 'resize',
                                cols: term.cols,
                                rows: term.rows
                            }));
                        }
                    }
                });
                
                // Check URL parameters for API-initiated connection
                const urlParams = new URLSearchParams(window.location.search);
                let sessionId = urlParams.get('session_id');
                const hostname = urlParams.get('hostname');
                const username = urlParams.get('username');
                const deviceName = urlParams.get('device_name');
                
                if (sessionId) {
                    // Extract just the session ID without any additional parameters
                    if (sessionId.includes('&')) {
                        sessionId = sessionId.split('&')[0];
                    }
                    
                    term.writeln('\x1b[1;34mConnecting to session: ' + sessionId + '\x1b[0m');
                    isApiConnection = true;
                    
                    // Update UI with available information
                    if (hostname) document.getElementById('device-hostname').textContent = hostname;
                    if (username) document.getElementById('connection-username').textContent = username;
                    document.getElementById('session-id').textContent = sessionId;
                    
                    // Connect directly to WebSocket without checking status
                    connectWebSocket(sessionId);
                }
            }, 100);
        }
        
        // Connect to WebSocket
        function connectWebSocket(sessionId) {
            if (ws) {
                ws.close();
            }
            
            currentSessionId = sessionId;
            
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws/${sessionId}`;
            
            term.writeln(`\x1b[1;34mConnecting to WebSocket: ${wsUrl}\x1b[0m`);
            
            ws = new WebSocket(wsUrl);
            
            // Set binary type to arraybuffer for better performance
            ws.binaryType = 'arraybuffer';
            
            ws.onopen = () => {
                term.writeln('\x1b[1;32mWebSocket connection established\x1b[0m');
                
                // Send terminal size
                const dimensions = { 
                    type: 'resize',
                    rows: term.rows,
                    cols: term.cols
                };
                ws.send(JSON.stringify(dimensions));
                
                // Apply fit again after connection to ensure correct size
                // But don't reset the terminal as that would clear the login banner
                setTimeout(() => {
                    if (fitAddon) {
                        // Store current dimensions before fitting
                        const prevRows = term.rows;
                        const prevCols = term.cols;
                        
                        // Apply fit
                        fitAddon.fit();
                        
                        // Only send resize if dimensions actually changed
                        if (prevRows !== term.rows || prevCols !== term.cols) {
                            ws.send(JSON.stringify({
                                type: 'resize',
                                cols: term.cols,
                                rows: term.rows
                            }));
                        }
                    }
                }, 500);
                
                // Focus the terminal so user can start typing immediately
                term.focus();
                
                // Handle terminal input with debouncing
                let inputQueue = [];
                let processingInput = false;
                
                term.onData(data => {
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        // Add the data to the queue
                        inputQueue.push(data);
                        console.log('Input queued:', data);
                        
                        // Process the queue if not already processing
                        if (!processingInput) {
                            processingInput = true;
                            processInputQueue();
                        }
                        
                        // For certain commands that need special handling
                        if (data.includes('top') || data.includes('htop') || data.includes('vi') || data.includes('vim') || data.includes('less') || data.includes('more')) {
                            console.log('Special command detected, scheduling extra refresh');
                            // Force additional refreshes for these commands
                            setTimeout(() => { term.refresh(0, term.rows - 1); }, 100);
                            setTimeout(() => { term.refresh(0, term.rows - 1); }, 500);
                            setTimeout(() => { term.refresh(0, term.rows - 1); }, 1000);
                            
                            // For top command specifically, set up a recurring refresh
                            if (data.includes('top')) {
                                console.log('Top command detected, setting up recurring refresh');
                                // Clear any existing refresh interval for top
                                if (window.topRefreshInterval) {
                                    clearInterval(window.topRefreshInterval);
                                }
                                
                                // Create a new refresh interval specifically for top
                                window.topRefreshInterval = setInterval(() => {
                                    if (term && document.hasFocus()) {
                                        term.refresh(0, term.rows - 1);
                                    }
                                }, 1000); // Refresh every second for top command
                                
                                // Listen for potential exit of top command
                                const checkForTopExit = (e) => {
                                    if (e.key === 'q' || e.key === 'Escape' || e.key === 'c' && e.ctrlKey) {
                                        // User likely exited top, clear the interval after a delay
                                        setTimeout(() => {
                                            if (window.topRefreshInterval) {
                                                clearInterval(window.topRefreshInterval);
                                                window.topRefreshInterval = null;
                                                console.log('Cleared top command refresh interval');
                                            }
                                        }, 500);
                                    }
                                };
                                
                                // Add and then remove the listener after a delay
                                document.addEventListener('keydown', checkForTopExit);
                                setTimeout(() => {
                                    document.removeEventListener('keydown', checkForTopExit);
                                }, 30000); // Remove after 30 seconds to avoid memory leaks
                            }
                        }
                    }
                });
                
                // Process the input queue with a small delay to prevent multiple messages
                function processInputQueue() {
                    if (inputQueue.length > 0) {
                        const data = inputQueue.shift();
                        
                        // Send the data to the server
                        console.log('Sending input to server:', data);
                        ws.send(JSON.stringify({
                            type: 'input',
                            data: data
                        }));
                        
                        // Process the next item in the queue after a small delay
                        setTimeout(processInputQueue, 10);
                    } else {
                        processingInput = false;
                    }
                }
                
                // Add key handling for special keys
                term.attachCustomKeyEventHandler(function(event) {
                    // Handle Ctrl+C and other special key combinations
                    if (event.ctrlKey && event.key === 'c' && event.type === 'keydown') {
                        // Force a refresh after Ctrl+C to ensure terminal state is updated
                        setTimeout(() => {
                            term.refresh(0, term.rows - 1);
                        }, 100);
                    }
                    return true; // Allow the default handler to process the event
                });
                
                // Initialize terminal with proper settings for escape sequences
                // We'll do this only once before the connection is established
                function initializeTerminal() {
                    // Only clear and reset the terminal BEFORE connection, not after
                    if (!ws || ws.readyState !== WebSocket.OPEN) {
                        // Clear the terminal first to remove any artifacts
                        term.clear();
                        
                        // Send sequences to reset terminal state
                        term.write('\u001bc'); // Full terminal reset (RIS - Reset to Initial State)
                        term.write('\u001b[0m'); // Reset all attributes
                        term.write('\u001b[?25h'); // Show cursor
                    }
                    
                    // Focus the terminal
                    term.focus();
                    
                    // Don't send an initial Enter key - let the user do it
                    // This helps prevent control sequence issues at login
                    console.log('Terminal initialized and ready for input');
                }
                
                // Call the initialization immediately to prepare the terminal
                initializeTerminal();
                
                // We don't need to call it again after connection is established
                // This prevents clearing the screen after login
                
                // Set up a connection health check
                // This will help detect and recover from stuck sessions
                const healthCheckInterval = setInterval(() => {
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        // Send a ping message to keep the connection alive
                        ws.send(JSON.stringify({ type: 'ping' }));
                        
                        // Check if we've received any data in the last 30 seconds
                        const now = Date.now();
                        if (window.lastMessageTime && (now - window.lastMessageTime > 30000)) {
                            console.log('No data received for 30 seconds, refreshing terminal');
                            // Force a terminal refresh
                            term.refresh(0, term.rows - 1);
                            
                            // If still no data after 60 seconds, consider reconnecting
                            if (window.lastMessageTime && (now - window.lastMessageTime > 60000)) {
                                console.log('Connection may be stuck, attempting to reconnect');
                                clearInterval(healthCheckInterval);
                                
                                // Try to reconnect
                                if (currentSessionId) {
                                    ws.close();
                                    setTimeout(() => {
                                        term.writeln('\x1b[1;33mConnection appears to be stuck, reconnecting...\x1b[0m');
                                        connectWebSocket(currentSessionId);
                                    }, 1000);
                                }
                            }
                        }
                    } else {
                        // WebSocket is closed or closing, clear the interval
                        clearInterval(healthCheckInterval);
                    }
                }, 10000); // Check every 10 seconds
                
                // Store the interval ID for cleanup
                window.healthCheckInterval = healthCheckInterval;
            };
            
            ws.onmessage = (event) => {
                console.log('WebSocket message received:', event.data);
                
                // Update the last message time for health check system
                window.lastMessageTime = Date.now();
                
                const data = event.data;
                if (data instanceof ArrayBuffer) {
                    // Handle binary data as ArrayBuffer (faster)
                    console.log('Binary data received (ArrayBuffer)');
                    const uint8Data = new Uint8Array(data);
                    term.write(uint8Data);
                    
                    // Force a refresh after receiving data to ensure display is updated
                    // This helps with commands like 'top' that use cursor positioning
                    term.refresh(0, term.rows - 1);
                } else if (data instanceof Blob) {
                    // Handle binary data as Blob (fallback)
                    const reader = new FileReader();
                    reader.onload = () => {
                        console.log('Binary data received (Blob)');
                        const uint8Data = new Uint8Array(reader.result);
                        term.write(uint8Data);
                        
                        // Force a refresh after receiving data
                        term.refresh(0, term.rows - 1);
                    };
                    reader.readAsArrayBuffer(data);
                } else {
                    try {
                        // Check if it's a JSON message
                        const jsonData = JSON.parse(data);
                        console.log('JSON data received:', jsonData);
                        
                        if (jsonData.type === 'output') {
                            console.log('Terminal output received:', jsonData.data);
                            term.write(jsonData.data);
                            
                            // Force a refresh after receiving output
                            term.refresh(0, term.rows - 1);
                        } else if (jsonData.type === 'error') {
                            showError(jsonData.data);
                        } else if (jsonData.type === 'status' && jsonData.status === 'disconnected') {
                            // Handle disconnection status
                            term.write('\r\n\nDisconnected from device\r\n');
                        } else if (jsonData.type === 'refresh') {
                            // Handle refresh notification from server
                            console.log('Received refresh notification, refreshing terminal display');
                            
                            // For full-screen applications, do a more thorough refresh
                            if (jsonData.fullscreen) {
                                console.log('Refreshing full-screen application');
                                // Clear selection to ensure cursor is visible
                                term.clearSelection();
                                
                                // Schedule multiple refreshes to ensure display is updated
                                setTimeout(() => { term.refresh(0, term.rows - 1); }, 10);
                                setTimeout(() => { term.refresh(0, term.rows - 1); }, 100);
                                setTimeout(() => { term.refresh(0, term.rows - 1); }, 500);
                            } else {
                                // Standard refresh
                                term.refresh(0, term.rows - 1);
                            }
                        } else if (jsonData.type === 'info') {
                            // Display informational messages
                            console.log('Server info:', jsonData.message);
                        } else {
                            console.log('Unknown message type:', jsonData.type);
                        }
                    } catch (e) {
                        // Not JSON, just write the data directly
                        console.log('Raw text data received:', data);
                        term.write(data);
                        
                        // Force a refresh after receiving text data
                        term.refresh(0, term.rows - 1);
                    }
                }
            };
            
            ws.onclose = () => {
                term.writeln('\x1b[1;31mWebSocket connection closed\x1b[0m');
                
                // Update UI elements
                document.getElementById('device-hostname').textContent = 'Not connected';
                document.getElementById('connection-username').textContent = 'Not connected';
                document.getElementById('session-id').textContent = 'Not connected';
                
                // Clear terminal
                term.clear();
                term.writeln('Connection closed');
                
                ws = null;
                currentSessionId = null;
            };
            
            ws.onerror = (error) => {
                showError('WebSocket error: ' + (error.message || 'Connection failed'));
                
                // Check if the error might be due to a session not found
                fetch(`/api/session/${sessionId}/status`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.status === 'not_found') {
                            term.writeln('\r\n\x1b[1;31mSession not found. The SSH connection may have failed or the session expired.\x1b[0m');
                            term.writeln('\r\n\x1b[1;33mPlease check if the SSH server is running and accessible.\x1b[0m');
                        }
                    })
                    .catch(err => {
                        console.error('Failed to check session status:', err);
                    });
            };
        }
        
        // Check session status and connect
        function checkSessionAndConnect(sessionId) {
            term.writeln(`\x1b[1;34mChecking session status for: ${sessionId}\x1b[0m`);
            
            fetch(`/api/session/${sessionId}/status`)
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'active') {
                        // Update UI elements
                        document.getElementById('device-hostname').textContent = data.hostname;
                        document.getElementById('connection-username').textContent = data.username;
                        document.getElementById('session-id').textContent = sessionId;
                        
                        // Connect WebSocket
                        connectWebSocket(sessionId);
                    } else if (data.status === 'closed') {
                        showError('Session is closed');
                    } else if (data.status === 'not_found') {
                        showError('Session not found');
                    } else {
                        showError('Unknown session status: ' + data.status);
                    }
                })
                .catch(error => {
                    showError('Failed to check session status: ' + error.message);
                });
        }
        
        // Disconnect function
        function disconnectSession() {
            if (currentSessionId) {
                term.writeln('\x1b[1;33mDisconnecting from session...\x1b[0m');
                
                fetch(`/api/session/${currentSessionId}/terminate`, {
                    method: 'POST'
                })
                .then(response => {
                    if (response.ok) {
                        term.writeln('\x1b[1;32mSession terminated successfully\x1b[0m');
                    } else {
                        showError('Failed to terminate session');
                    }
                    
                    // Clean up terminal state regardless of success/failure
                    cleanupTerminal();
                })
                .catch(error => {
                    showError('Error terminating session: ' + error.message);
                    // Clean up terminal state even on error
                    cleanupTerminal();
                });
                
                if (ws) {
                    ws.close();
                }
            } else {
                term.writeln('\x1b[1;33mNo active session to disconnect\x1b[0m');
            }
            
            // Helper function to clean up terminal state
            function cleanupTerminal() {
                // Clear any refresh intervals
                if (window.topRefreshInterval) {
                    clearInterval(window.topRefreshInterval);
                    window.topRefreshInterval = null;
                    console.log('Cleared top command refresh interval');
                }
                
                // Reset terminal UI elements
                document.getElementById('device-hostname').textContent = 'Not connected';
                document.getElementById('connection-username').textContent = 'Not connected';
                document.getElementById('session-id').textContent = 'Not connected';
                
                // Force a terminal refresh to ensure clean state
                term.refresh(0, term.rows - 1);
                
                // Reset terminal options to default state
                term.options.cursorBlink = true;
                term.options.cursorStyle = 'block';
                
                // Apply fit to ensure terminal size is correct
                if (fitAddon) {
                    setTimeout(() => {
                        fitAddon.fit();
                    }, 100);
                }
                
                // Reset current session ID
                currentSessionId = null;
            }
        }
        
        // Reconnect function
        function reconnectSession() {
            if (currentSessionId) {
                term.writeln('\x1b[1;33mReconnecting to session: ' + currentSessionId + '\x1b[0m');
                connectWebSocket(currentSessionId);
            } else {
                // Check URL parameters for session ID
                const urlParams = new URLSearchParams(window.location.search);
                let sessionId = urlParams.get('session_id');
                
                if (sessionId) {
                    // Extract just the session ID without any additional parameters
                    if (sessionId.includes('&')) {
                        sessionId = sessionId.split('&')[0];
                    }
                    
                    term.writeln('\x1b[1;33mReconnecting to session: ' + sessionId + '\x1b[0m');
                    connectWebSocket(sessionId);
                } else {
                    term.writeln('\x1b[1;33mNo session ID available for reconnection\x1b[0m');
                }
            }
        }
        
        // Send Enter key function
        function sendEnterKey() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                term.writeln('\x1b[1;33mSending Enter key...\x1b[0m');
                ws.send(JSON.stringify({ type: 'input', data: '\r' }));
            } else {
                term.writeln('\x1b[1;33mWebSocket not connected\x1b[0m');
            }
        }
        
        // Handle window resize with debounce to prevent too many resize events
        let resizeTimeout;
        window.onresize = function() {
            // Clear any existing timeout to debounce the resize event
            if (resizeTimeout) {
                clearTimeout(resizeTimeout);
            }
            
            // Set a timeout to actually perform the resize after a short delay
            // This prevents sending too many resize events in rapid succession
            resizeTimeout = setTimeout(function() {
                if (fitAddon) {
                    // Store previous dimensions
                    const prevRows = term.rows;
                    const prevCols = term.cols;
                    
                    // Fit the terminal to the container
                    fitAddon.fit();
                    
                    // Only send resize command if dimensions actually changed
                    // This prevents unnecessary resize commands
                    if (prevRows !== term.rows || prevCols !== term.cols) {
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            console.log(`Terminal resized from ${prevCols}x${prevRows} to ${term.cols}x${term.rows}`);
                            const dimensions = {
                                type: 'resize',
                                rows: term.rows,
                                cols: term.cols
                            };
                            ws.send(JSON.stringify(dimensions));
                        }
                    }
                }
            }, 250); // 250ms debounce time
        };
        
        // Initialize on page load
        window.onload = function() {
            initTerminal();
        };
    </script>
</body>
</html>
